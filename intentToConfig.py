# -*- coding: utf-8 -*-
"""
TODO:
remplacer no ip adress par l'adress ip ligne 65

configuration complète rip

config complète ospf

config complète bgp:
"""
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m5UpCKltU-KlR03cPZnnT6hvirHA5h9P
"""

import os
import json
from datetime import datetime
import dragAndDrop
import sys

# Fonction pour générer la configuration pour un routeur
def generate_router_config(router, as_data, is_ebgp):
    config = []
    config.append("!\n!\n!\n!")
    config.append("!")
    config.append("version 15.2")
    config.append("service timestamps debug datetime msec")
    config.append("service timestamps log datetime msec")
    config.append("!")
    config.append(f"hostname {router['hostname']}")
    config.append("!")
    config.append("boot-start-marker")
    config.append("boot-end-marker")
    config.append("!")
    config.append("no aaa new-model")
    config.append("no ip icmp rate-limit unreachable")
    config.append("ip cef")
    config.append("!")
    config.append("ipv6 unicast-routing")
    config.append("ipv6 cef")
    config.append("!")
    config.append("interface Loopback1")
    config.append(" no ip address")
    config.append(f" ipv6 address {as_data['prefix_loopback_ip']}::{router['hostname'][-2:]}/128")
    config.append(" ipv6 enable")
    config.append("!")

    for interface in router["interfaces"]:
        int_name = f"GigabitEthernet{interface['gigabitEthernet']}/0"
        prefix_ip = as_data["prefix_interface_ip"] 
        interface_ip = f"{prefix_ip}{interface['gigabitEthernet']}::1/64"
        print(interface_ip)
        config.append(f"interface {int_name}")
        config.append("no ip address")
        config.append(f" ipv6 address {interface_ip}")
        config.append(" ipv6 enable")
        config.append(" no shutdown")
        config.append(" negotiation auto")
        config.append("!")


    if is_ebgp:
        config.append(f"router bgp {as_data['bgp']['local_as']}")
        config.append(f" bgp router-id {router['id']}")
        config.append(" bgp log-neighbor-changes")
        config.append(" no bgp default ipv4-unicast")
        for neighbor in as_data["bgp"]["egbp_neighbors"]:
            if neighbor["connected_router"] == router["hostname"]:
                config.append(f" neighbor {neighbor['to_router_ip']} remote-as {neighbor['to_as']}")
    else:
        config.append(f"router bgp {as_data['bgp']['local_as']}")
        config.append(f" bgp router-id {router['id']}")
        config.append(" bgp log-neighbor-changes")
        for peer in as_data["bgp"]["ibgp"][0]["peers"]:
            if peer != router["hostname"]:
                config.append(f" neighbor {peer} remote-as {as_data['bgp']['local_as']}")
    config.append("!")
    config.append("end")
    return "\n".join(config)


def generate_all_router(network_data, path):
    for as_data in network_data["AS"]:
        for router in as_data["routers"]:
            # Vérifier si le routeur utilise eBGP
            hostname = router['hostname']
            is_ebgp = hostname in [neighbor["connected_router"] for neighbor in as_data["bgp"]["egbp_neighbors"]]
            # Générer la configuration
            config = generate_router_config(router, as_data, is_ebgp)
            newPath = path + dragAndDrop.dicoCorrespondance[hostname]["idRouter"]
            dragAndDrop.dragAndDropRouter(hostname,newPath,config)

def start_generation(path):
    # Charger les données JSON à partir d'un fichier externe
    with open("Intent.json", "r") as file:
        network_data = json.load(file)
        
    # Générer les fichiers de configuration pour chaque routeur
    generate_all_router(network_data, path)
    print(f"Configurations générées dans le dossier '{path}'")
    

start_generation(sys.argv[1])