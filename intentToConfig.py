# -*- coding: utf-8 -*-
"""
TODO:
remplacer no ip adress par l'adress ip ligne 65

configuration complète rip

config complète ospf

config complète bgp:
"""
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m5UpCKltU-KlR03cPZnnT6hvirHA5h9P
"""

import os
import json
from datetime import datetime

# Fonction pour générer la configuration pour un routeur
def generate_router_config(router, as_data, is_ebgp):
    config = []
    config.append("!\n!\n!\n!")
    config.append("!")
    config.append("version 15.2")
    config.append("service timestamps debug datetime msec")
    config.append("service timestamps log datetime msec")
    config.append("!")
    config.append(f"hostname {router['hostname']}")
    config.append("!")
    config.append("boot-start-marker")
    config.append("boot-end-marker")
    config.append("!")
    config.append("no aaa new-model")
    config.append("no ip icmp rate-limit unreachable")
    config.append("ip cef")
    config.append("!")
    config.append("ipv6 unicast-routing")
    config.append("ipv6 cef")
    config.append("!")
    config.append("interface Loopback1")
    config.append(f" ipv6 address {as_data['prefix_loopback_ip']}::{router['hostname'][-2:]}/128")
    config.append(" ipv6 enable")
    config.append("!")

    for interface in router["interfaces"]:
        int_name = f"GigabitEthernet{interface['gigabitEthernet']}/0"
        prefix_ip = as_data["prefix_interface_ip"] 
        interface_ip = f"{prefix_ip}{router['hostname'][-2:]}{interface['gigabitEthernet']}::1/64"


        config.append(f"interface {int_name}")
        config.append(f" ipv6 address {interface_ip}")
        config.append(" ipv6 enable")
        config.append(" shutdown")
        config.append(" negotiation auto")
        config.append("!")


    if is_ebgp:
        config.append(f"router bgp {as_data['bgp']['local_as']}")
        config.append(f" bgp router-id {router['id']}")
        config.append(" bgp log-neighbor-changes")
        for neighbor in as_data["bgp"]["egbp_neighbors"]:
            if neighbor["connected_router"] == router["hostname"]:
                config.append(f" neighbor {neighbor['to_router_ip']} remote-as {neighbor['to_as']}")
    else:
        config.append(f"router bgp {as_data['bgp']['local_as']}")
        config.append(f" bgp router-id {router['id']}")
        config.append(" bgp log-neighbor-changes")
        for peer in as_data["bgp"]["ibgp"][0]["peers"]:
            if peer != router["hostname"]:
                config.append(f" neighbor {peer} remote-as {as_data['bgp']['local_as']}")
    config.append("!")
    config.append("end")
    return "\n".join(config)


def generate_all_router(network_data, output_directory):
    for as_data in network_data["AS"]:
        for router in as_data["routers"]:
            # Vérifier si le routeur utilise eBGP
            is_ebgp = router["hostname"] in [neighbor["connected_router"] for neighbor in as_data["bgp"]["egbp_neighbors"]]
            # Générer la configuration
            config = generate_router_config(router, as_data, is_ebgp)
            # Écrire la configuration dans un fichier .cfg
            file_path = os.path.join(output_directory, f"i{router['hostname'].lstrip('R')}_startup-config.cfg")
            with open(file_path, "w") as file:
                file.write(config)

def start_generation():
    # Charger les données JSON à partir d'un fichier externe
    with open("Intent.json", "r") as file:
        network_data = json.load(file)
        
    # Générer les fichiers de configuration pour chaque routeur
    output_directory = "router_configs"
    os.makedirs(output_directory, exist_ok=True)
    generate_all_router(network_data, output_directory)
    print(f"Configurations générées dans le dossier '{output_directory}'")
    
start_generation()